<link rel="import" href="../bower_components/polymer/polymer-element.html">
<script src="../bower_components/Sortable/Sortable.js"></script>

<dom-module id="sortable-js">
  <template>
    <slot></slot>
  </template>
  <script>
    class SortableJS extends Polymer.Element {
      static get is() {
        return 'sortable-js';
      }

      static get properties() {
        return {
          group: {
            type: Object, value: () => {
              return {name: Math.random()};
            }, observer: "groupChanged"
          },
          sort: {type: Boolean, value: true, observer: "sortChanged"},
          disabled: {type: Boolean, value: false, observer: "disabledChanged"},
          store: {type: Object, value: null, observer: "storeChanged"},
          handle: {type: String, value: null, observer: "handleChanged"},
          scrollSensitivity: {type: Number, value: 30, observer: "scrollSensitivityChanged"},
          scrollSpeed: {type: Number, value: 10, observer: "scrollSpeedChanged"},
          ghostClass: {type: String, value: "sortable-ghost", observer: "ghostClassChanged"},
          chosenClass: {type: String, value: "sortable-chosen", observer: "chosenClassChanged"},
          ignore: {type: String, value: "a, img", observer: "ignoreChanged"},
          filter: {type: Object, value: null, observer: "filterChanged"},
          animation: {type: Number, value: 0, observer: "animationChanged"},
          dropBubble: {type: Boolean, value: false, observer: "dropBubbleChanged"},
          dragoverBubble: {type: Boolean, value: false, observer: "dragoverBubbleChanged"},
          dataIdAttr: {type: String, value: "data-id", observer: "dataIdAttrChanged"},
          delay: {type: Number, value: 0, observer: "delayChanged"},
          forceFallback: {type: Boolean, value: false, observer: "forceFallbackChanged"},
          fallbackClass: {type: String, value: "sortable-fallback", observer: "fallbackClassChanged"},
          fallbackOnBody: {type: Boolean, value: false, observer: "fallbackOnBodyChanged"},
          draggable: {},
          scroll: {}
        };
      }

      constructor() {
        super();
        // override default DOM property behavior
        Object.defineProperties(this, {
          draggable: {
            get: function () {
              return this._draggable || this.getAttribute("draggable") || ">*";
            }, set: function (value) {
              this._draggable = value;
              this.draggableChanged(value);
            }
          },
          scroll: {
            get: function () {
              return this._scroll || JSON.parse(this.getAttribute("scroll") || "true");
            }, set: function (value) {
              this._scroll = value;
              this.scrollChanged(value);
            }
          }
        });
      }

      attached() {
        super.attached();
        // Given
        //   <sortable-js>
        //     <template is="dom-repeat" items={{data}}>
        //       <div>
        //         <template is="dom-if" if="true">
        //           <span>hello</span></template></div>
        // After render, it becomes
        //   <sortable-js>
        //     <div>
        //       <span>hello</span>
        //       <template is="dom-if">
        //     <template is="dom-repeat">
        this.initialize();
      }

      detached() {
        super.detached();
        this.destroy();
      }

      initialize() {
        const templates = this.querySelectorAll("template[is='dom-repeat']");
        const template = templates[templates.length - 1];
        const eventCallbacks = {
          onUpdate: (detail) => {
            if (template)
              template.splice('items', detail.newIndex, 0, template.splice("items", detail.oldIndex, 1)[0]);
            this.dispatchEvent(new CustomEvent('update', {detail}));
          },
          onAdd: (detail) => {
            if (template) {
              const froms = detail.from.querySelectorAll("template[is='dom-repeat']");
              const from = froms[froms.length - 1];
              const model = from.modelForElement(detail.item);
              template.splice("items", detail.newIndex, 0, model.item);
              detail.model = model;
            }
            this.dispatchEvent(new CustomEvent('add', {detail}));
          },
          onRemove: (detail) => {
            // Do not remove if group.pull is clone
            if (detail.target.group.pull === 'clone')
              return false;
            if (template) {
              const item = template.splice('items', detail.oldIndex, 1)[0];
              detail.model = {item};
            }
            this.dispatchEvent(new CustomEvent('remove', {detail}));
          },
          onChoose: (detail) => this.dispatchEvent(new CustomEvent('choose', {detail})),
          onStart: (detail) => this.dispatchEvent(new CustomEvent('start', {detail})),
          onEnd: (detail) => this.dispatchEvent(new CustomEvent('end', {detail})),
          onSort: (detail) => this.dispatchEvent(new CustomEvent('sort', {detail})),
          onFilter: (detail) => this.dispatchEvent(new CustomEvent('filter', {detail})),
          onMove: (detail) => this.dispatchEvent(new CustomEvent('move', {detail})),
          onClone: (detail) => this.dispatchEvent(new CustomEvent('clone', {detail})),
        };
        this.sortable = Sortable.create(this, {...this.properties, ...eventCallbacks});
      }

      destroy() {
        if (this.sortable)
          this.sortable.destroy();
      }

      groupChanged(value) {
        if (typeof(value) === 'string')
          return this.set('group', {name: value});
        this.sortable && this.sortable.option('group', value);
      }

      sortChanged(value) {
        this.sortable && this.sortable.option('sort', value);
      }

      disabledChanged(value) {
        this.sortable && this.sortable.option('disabled', value);
      }

      storeChanged(value) {
        this.sortable && this.sortable.option('store', value);
      }

      handleChanged(value) {
        this.sortable && this.sortable.option('handle', value);
      }

      scrollChanged(value) {
        this.sortable && this.sortable.option('scroll', value);
      }

      scrollSensitivityChanged(value) {
        this.sortable && this.sortable.option('scrollSensitivity', value);
      }

      scrollSpeedChanged(value) {
        this.sortable && this.sortable.option('scrollSpeed', value);
      }

      draggableChanged(value) {
        this.sortable && this.sortable.option('draggable', value);
      }

      ghostClassChanged(value) {
        this.sortable && this.sortable.option('ghostClass', value);
      }

      chosenClassChanged(value) {
        this.sortable && this.sortable.option('chosenClass', value);
      }

      ignoreChanged(value) {
        this.sortable && this.sortable.option('ignore', value);
      }

      filterChanged(value) {
        this.sortable && this.sortable.option('filter', value);
      }

      animationChanged(value) {
        this.sortable && this.sortable.option('animation', value);
      }

      dropBubbleChanged(value) {
        this.sortable && this.sortable.option('dropBubble', value);
      }

      dragoverBubbleChanged(value) {
        this.sortable && this.sortable.option('dragoverBubble', value);
      }

      dataIdAttrChanged(value) {
        this.sortable && this.sortable.option('dataIdAttr', value);
      }

      delayChanged(value) {
        this.sortable && this.sortable.option('delay', value);
      }

      forceFallbackChanged(value) {
        this.sortable && this.sortable.option('forceFallback', value);
      }

      fallbackClassChanged(value) {
        this.sortable && this.sortable.option('fallbackClass', value);
      }

      fallbackOnBodyChanged(value) {
        this.sortable && this.sortable.option('fallbackOnBody', value);
      }
    }

    window.customElements.define(SortableJS.is, SortableJS);
  </script>
</dom-module>
